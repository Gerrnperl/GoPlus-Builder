## 素材列表

#### AssetList

暴露给客户端，返回素材列表

```Go
type CategoryCollection map[string]string
type ListAssetsParams struct {
        .....
        // just this field changed
        Category *CategoryCollection
        .....
}
func (ctrl *Controller)ListAssets(ctx context.Context, params *ListAssetsParams) (*model.ByPage[model.Asset], error){
    index = nil
    if ListAssetsParams.keyword != nil{
        // word to vector
        vec = Embedding(ListAssetsParams.keyword)
        // search in vector database
        index = model.searchByEmbedding(vec)
    }
    assets = model.ListAssets(ctx, ctrl.db, params.Pagination, wheres, orders, index)
    return assets
}
```

#### Embedding（AI）

实现 将文本encode的功能

会调用 AI 侧能力

```Go
type EmbeddingParams struct {
    // word is the word to be embedded.
    Word string `json:"word"`
}
type EmbeddingResult struct{
    // embedding is the vector transformed by the statement
    Embedding []float64 `json:"embedding"`
}
func (ctrl *Controller) Embedding(word string){
	params = struct{
		Word string `json:"word"`
    }{
        Word : Word
    }
	result = struct{
        Embedding []float64 `json:"embedding"`
    }
    // call aigc service
    ctrl.aicgService.Call(ctx, http.MethodPost, "/embedding", &params, &result)
    return result.Embedding
}
```

POST /embedding

- Request body

```JSON
{
  "word": "string",
}
```

- Response body

```JSON
{
  "embedding": ["int"],
}
```

## 文本生成图片

#### TextGenSpriteImage

```Go
type GenSpriteImageParams{
    Category CategoryCollection
    Keyword string
}
type GenSpriteImageResult{
    ImageJobId string `json:"ImageJobId"`
}
func (ctrl *Controller) GenSpriteImage(ctx context.Context, params *GenSpriteImageParams)(*GenSpriteImageResult , err){
    // combine the category and keyword in the request into text suitable for input into ai
    textDesc = paramsToText(params)
    // since the ai side currently only supports synchronization 
    // asynchronous is performed here in the backend.
    jobId = model.AddJob(jobType)
    // the coroutine request calls the ai-side service
    go textGenImage(jobId, textDesc)
    // return
    return &GenSpriteImageResult{
        ImageJobId : jobId
    }
}
```

#### TextGenBackdropImage

```Go
type GenBackdropImageParams{
    Category CategoryCollection
    Keyword string
    Width int
    Height int
}
type GenBackdropImageResult{
    ImageJobId string
}
func (ctrl *Controller) GenBackdropImage(ctx context.Context, params *GenBackdropImageParams){
    // combine the category, keyword and resolution in the request into 
    // text suitable for input into ai
    textDesc = paramsToText(params)
    // Since the ai side currently only supports synchronization 
    // asynchronous is performed here in the backend.
    jobId = model.AddJob(jobType)
    
	result = GenBackdropImageResult{
        ImageJobId = jobId
    }
    // the coroutine request calls the ai-side service
    go textGenImage(jobId, textDesc)
    // return
    return &GenBackdropImageResult{
        ImageJobId : jobId
    }
}
```

#### TextGenImage（AI）

```Go
type TextGenImageResult struct{
    // the url of generate
    ImageUrl string `json:"imageUrl"`
}
func textGenImage(jobId int, textDesc string){
    params = struct{
        TextDesc string `json:"textDesc"`
    }{
        TextDesc = textDesc
    }
    result = struct{
        ImageUrl string `json:"imageUrl"`
    }
    // calls the ai-side service
    ctrl.aicgService.Call(ctx, http.MethodPost, "/textGenImage", &params, &result)
    // write results back to database
    model.UpdateAsset(jobId, result.ImageUrl)
}
```

POST /textGenImage

- Request body

```JSON
{
  "textDesc": "string",
}
```

- Response body

```JSON
{
  "imageUrl": "string",
}
```

## 图片生成精灵

#### ImageGenSprite

```Go
type ImageGenSpriteParams struct{
    ImageJobId string `json:"imageJobId"`
}
type ImageGenSpriteResult struct {
    JobId string `json:"jobId"`
}
func (ctrl *Controller) ImageGenSprite(ctx context.Context, params *ImageGenSpriteParams){
    // get the URL of the AI-generated image through the jobid generated by the AI image.
    imageUrl = model.getImageUrl(params.ImageJobId)
    // Since the ai side currently only supports synchronization 
    // asynchronous is performed here in the backend.
    jobId = model.AddJob(jobType)
	
    // the coroutine request calls the ai-side service
    go genAsset(jobId, imageUrl)
    // return
    return &ImageGenSpriteResult{
        JobId = jobId
    }
}
```

#### ImageGenAsset（AI）

```Go
type genResult struct{
    Files FileCollection `json:"files"`
}

type FileCollection map[string]string

func genAsset(jobId int,imageUrl string){
    params = struct{
        ImageUrl string `json:"imageUrl"`
    }{
        ImageUrl = imageUrl
    }
    result = struct{
        Files FileCollection `json:"files"`
    }
    // calls the ai-side service
    ctrl.aicgService.Call(ctx, http.MethodPost, "/imageGenSprite", &params, &result)
    // write results back to database
    model.UpdateJob(jobId , result.Files)
}
```

POST /imageGenSprite

- Request body

```JSON
{
  "imageUrl": "string",
}
```

- Response body

```JSON
{
  "files": {
      "imageUrl": "string",
      "skeletonUrl" : "string",
      "animMeshUrl" : "string",
      "frameDataUrl" : "string"
  },
}
```

## 查询生成状态

#### GenStatus

```Go
type GenStatusParams struct {
    JobId string `json:"jobId"`
}
type genResult{
    jobId string 'json:"jobId"'
    jobType int 'json:"jobType"'
    files FileCollection `json:"files"`
}


type GenStatusResult struct{
    Status int 'json:"status"'
    Result GenResult`json:"result"`
}

func (ctrl *Controller) GenStatus(ctx context.Context, params *GenStatusParams){
    // query job status
    statusResult = model.getJob(params.jobId)
    return &{
        Status = statusResult.Status
        Result = statusResult.Result
    }
}
```

## 收藏/添加模块

#### ExportAiAsset

```Go
type ExportAiAssetParams{
    JobId string 'json:"jobId"'
}
type ExportAiAssetResult{
    AssetId string 'json:"assetId"'
}
func (ctrl *Controller) ExportAiAsset(ctx context.Context, params *ExportAiAssetParams){
    addAssetParams = model.getJob(params.JobId)
    //write to vector database
    model.addByVec(addAssetParams)
    // write to database
    asset = model.AddAsset(ctx, addAssetParams)
    return &ExportAiAssetResult{
        AssetId = asset.id
    }
}
```

#### History

```Go
type HistoryParams{
    AssetId string 'json:"assetId"'
}
func (ctrl *Controller) AddHistory(ctx context.Context, params *HistoryParams){
    model.AddHistory(ctx, params.AssetId)
}
```

#### Favorite

```Go
type FavoriteParams{
    AssetId string 'json:"assetId"'
}
func AddFavorite(ctx context.Context, params *FavoriteParams){
    model.AddFavorite(ctx, params.AssetId)
}
```